<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="https://img.songhn.com/img/Y67gdd.png" rel="icon"><title>CoordinatorLayout的秘密之Behavior</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.2.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="https://img.songhn.com/img/Y67gdd.png" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">逆境中挣扎，享受快乐</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>6</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>5</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>3</span> <span>标签</span> </a><a class="author-word-count"><span>2.5</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Behavior%E7%9A%84%E8%83%BD%E5%8A%9B" class="toc-link"><span class="toc-text">Behavior的能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%AE%BE%E7%BD%AEBehavior" class="toc-link"><span class="toc-text">如何使用设置Behavior</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#xml%E4%B8%AD%E8%AE%BE%E7%BD%AE" class="toc-link"><span class="toc-text">xml中设置</span></a></li><li class="toc-item toc-level-4"><a href="#%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B" class="toc-link"><span class="toc-text">直接创建实例</span></a></li><li class="toc-item toc-level-4"><a href="#%E9%80%9A%E8%BF%87%E9%BB%98%E8%AE%A4%E7%9A%84Behavior%E8%AE%BE%E7%BD%AE" class="toc-link"><span class="toc-text">通过默认的Behavior设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#Behavior%E7%9A%84%E5%8A%9F%E8%83%BD" class="toc-link"><span class="toc-text">Behavior的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80" class="toc-link"><span class="toc-text">测量和布局</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%B8%83%E5%B1%80%E4%BE%9D%E8%B5%96" class="toc-link"><span class="toc-text">布局依赖</span></a></li><li class="toc-item toc-level-4"><a href="#%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA%E5%A4%84%E7%90%86" class="toc-link"><span class="toc-text">事件拦截处理</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8" class="toc-link"><span class="toc-text">嵌套滑动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android/"><div class="categories-list-item">Android <span class="categories-list-item-badge">5</span></div></a><a href="/categories/Android/NestedScroll/"><div class="categories-list-item">NestedScroll <span class="categories-list-item-badge">1</span></div></a><a href="/categories/Android/Hilt/"><div class="categories-list-item">Hilt <span class="categories-list-item-badge">1</span></div></a><a href="/categories/Android/Room/"><div class="categories-list-item">Room <span class="categories-list-item-badge">1</span></div></a><a href="/categories/Android/Behavior/"><div class="categories-list-item">Behavior <span class="categories-list-item-badge">1</span></div></a></div></div></article></div></aside><main class="main-column"><article class="card card-content article-content"><header><h1 class="post-title">CoordinatorLayout的秘密之Behavior</h1></header><div class="post-meta post-show-meta"><time datetime="2021-11-02T13:54:58.000Z"><i class="iconfont icon-calendar" style="margin-right:2px"></i> <span>2021-11-02</span> </time><span class="dot"></span> <a href="/categories/Android/" class="post-meta-link">Android </a><a href="/categories/Android/Behavior/" class="post-meta-link">Behavior </a><span class="dot"></span> <span>5.2k 字</span></div><div class="post-meta post-show-meta" style="margin-top:-10px"><div style="display:flex;align-items:center"><i class="iconfont icon-biaoqian" style="margin-right:2px;font-size:1.15rem"></i> <a href="/tags/View/" class="post-meta-link">View</a></div></div><div class="post-content" id="section"><p><img alt="cover-behavior.webp" class="lozad post-image" src="/img/cover-behavior.webp" data-src="/img/cover-behavior.webp" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E"></p><p>在源码的注释的第一行中有这样一句话：<code>CoordinatorLayout is a super-powered FrameLayout.</code> 也就是什么都不做的话，是可以将他当做一个简单的<code>FrameLayout</code>来使用的，当然实际上我们肯定不会这样去使用的。从名字可以看到，<code>CoordinatorLayout</code>是一个协调布局、协作布局。即作为一个控制者，处理子View之间的交互关系。</p><p><code>CoordinatorLayout</code>是用于操控子View的行为模式的，它将操控的能力全部抽取出来，组成一个静态内部类<code>Behavior</code>，通过<code>Behavior</code>来实现操控能力，也更方便拓展。因此，<code>CoordinatorLayout</code>必须搭配<code>Behavior</code>来使用，否则失去操控能力的它就变得及其简单，也就是源码注释中说的<code>super-powered FrameLayout</code>。</p><h2 id="Behavior的能力"><a href="#Behavior的能力" class="headerlink" title="Behavior的能力"></a>Behavior的能力</h2><p><code>CoordinatorLayout</code>将其所支持的各种功能都抽象出来，作为一个插件标准，所有人都可以依据这个插件标准，来使用它的各种能力。这个插件标准就是<code>Behavior</code></p><p>说白了Android原生View之间的各种花样也不过布局绘制、事件操作等。而<code>CoordinatorLayout</code>所实现的就是一些常用的功能，如<strong>依赖关系</strong>、<strong>测量布局</strong>、<strong>Touch事件</strong>、<strong>嵌套滑动</strong>。</p><h3 id="如何使用设置Behavior"><a href="#如何使用设置Behavior" class="headerlink" title="如何使用设置Behavior"></a>如何使用设置Behavior</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Behavior</span>&lt;V <span class="keyword">extends</span> <span class="title class_">View</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Behavior</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Behavior</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Behavior</code>有两个构造方法，一个是空参数的构造方法，一个是双参数的构造方法。对于熟悉自定义<code>View</code>的我们而言，双参数的构造方法一看就是对应从<code>xml</code>中实例化出来的。事实确实如此，空参数的构造方法一般都是手动去创建实例然后设置，而双参数的一般都是直接在<code>xml</code>中设置。</p><p>注意：</p><ul><li><p>**一个子<code>View</code>只能设置一个<code>Behavior</code>**。</p></li><li><p><strong>泛型V表示的是该Behavior可用于的类型，例如设置为<code>ImageView</code>，则实例化的<code>Behavior</code>只能用于<code>ImageView</code>。</strong></p></li></ul><h4 id="xml中设置"><a href="#xml中设置" class="headerlink" title="xml中设置"></a>xml中设置</h4><p>直接在<code>xml</code>中通过<code>app:layout_behavior=&quot;xxx&quot;</code>给某个子view设置<code>Behavior</code>，其中<code>xxx</code>表示的是<code>Behavior</code>的类名。可以是缩略的如<code>.MyBehavior</code>，也可以是完整的如<code>com.xx.test.MyBehavior</code>。<strong>建议使用完整包名</strong>，毕竟当在<code>xml</code>中重定义<code>package</code>的时候，使用缩略名称会导致出错。</p><p>当通过xml声明的方式去设置<code>Behavior</code>的时候，会走双参数的构造方法，此时，可以通过xml属性向其设置参数，使用方式和自定义View的自定义属性是一样的。</p><ul><li>1，在<code>attrs.xml</code>中定义属性和名称，和自定义<code>view</code>的做法一致</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;MovableButton_Behavior&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">format</span>=<span class="string">&quot;string&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2，在<code>xml</code>中设置这个属性</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/image&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;.behavior.AttrBehavior&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:sex</span>=<span class="string">&quot;aaaa&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在<code>Behavior</code>构造方法中读取属性</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AttrBehavior</span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attributeSet: AttributeSet</span><br><span class="line">) : CoordinatorLayout.Behavior&lt;View&gt;(context, attributeSet) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        context.obtainStyledAttributes(attributeSet, R.styleable.MovableButton_Behavior).use &#123;</span><br><span class="line">            <span class="keyword">val</span> sex = it.getString(R.styleable.MovableButton_Behavior_sex)</span><br><span class="line">            println(<span class="string">&quot;xml中设置的app:sex属性值为：<span class="variable">$sex</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接创建实例"><a href="#直接创建实例" class="headerlink" title="直接创建实例"></a>直接创建实例</h4><p>若是不在xml中设置的话，则需要手动创建，然后设置给对应的View。这种方式稍微复杂一点点：需要首先拿到想要设置的Behavior的View，然后获取其布局属性<code>CoordinatorLayout.LayoutParams</code>，然后通过<code>setBehavior</code>方式设置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    <span class="keyword">val</span> textView:TextView = findViewById(R.id.textView)</span><br><span class="line">    <span class="keyword">val</span> params = textView.layoutParams</span><br><span class="line">    <span class="keyword">if</span> (params <span class="keyword">is</span> CoordinatorLayout.LayoutParams) &#123;</span><br><span class="line">        <span class="comment">// 设置Behavior</span></span><br><span class="line">        params.behavior = AttrBehavior()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过默认的Behavior设置"><a href="#通过默认的Behavior设置" class="headerlink" title="通过默认的Behavior设置"></a>通过默认的Behavior设置</h4><p>使用默认的设置，就是没有使用前两种方式设置的话才会使用默认的。以前是通过注解的方式去设置，这种方式需要自定义View，然后在其类名上通过<code>@DefaultBehavior</code>进行注解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DefaultBehavior(AttrBehavior::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovableButton</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyle: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : AppCompatButton(context, attr, defStyle)</span><br></pre></td></tr></table></figure><p>注意：注解方式已经被标记为<code>Deprecated</code>，不再推荐使用了，现在推荐使用接口的方式来实现，即自定义的View通过实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AttachedBehavior</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span> Behavior <span class="title function_">getBehavior</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Behavior的功能"><a href="#Behavior的功能" class="headerlink" title="Behavior的功能"></a>Behavior的功能</h3><p><code>CoordinatorLayout</code>抽取的比较狠，它将所有的操作都抽取到了<code>Behavior</code>中，本身基本上没有什么特殊功能了。也就是说如果离了<code>Behavior</code>，它就是一个<code>FrameLayout</code>了。</p><h4 id="测量和布局"><a href="#测量和布局" class="headerlink" title="测量和布局"></a>测量和布局</h4><p>一个<code>View</code>的显示，通常经历三个步骤：测量、布局、绘制。而在<code>Behavior</code>中也能实现前两个步骤，这是因为<code>CoordinatorLayout</code>将其对子<code>View</code>的测量和布局的过程放在了<code>Behavior</code>中。它本身对于子View的布局就是单纯的叠加，也就是<code>FrameLayout</code>那样，如果想要特殊的测量和布局的话，则需要在<code>Behavior</code>中自己去实现了。</p><p>测量和布局对应的方法名称和<code>View</code>的方法非常类似，直接在<code>Behavior</code>中重写这两个方法实现自定义测量和布局，然后返回<code>true</code>即可。注意，<strong>必须返回true</strong>，否则当前自定义不会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">onMeasureChild</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout parent, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> parentWidthMeasureSpec,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> widthUsed,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> parentHeightMeasureSpec, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> heightUsed</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">    </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">onLayoutChild</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout parent, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> layoutDirection</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>相对而言，自定义测量<code>onMeasureChild</code>用的较少，因为默认情况下父布局会像<code>FrameLayout</code>那样去测量子<code>View</code>，这种测量方式基本上已经够用了，而<code>onLayoutChild</code>用的会多一些。</p><p>查看下面的实例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LayoutBehavior</span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet</span><br><span class="line">) : Behavior&lt;ImageView&gt;(context, attr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayoutChild</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: <span class="type">CoordinatorLayout</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        child: <span class="type">ImageView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        layoutDirection: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> target: Button? = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 遍历子View，查找第一个类型为Button的子View</span></span><br><span class="line">        <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0.</span>.parent.childCount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent.getChildAt(index) <span class="keyword">is</span> Button) &#123;</span><br><span class="line">                target = parent.getChildAt(index) <span class="keyword">as</span> Button</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将应用了Behavior的子View放置在第一个Button的右下方</span></span><br><span class="line">            child.layout(</span><br><span class="line">                target.right,</span><br><span class="line">                target.bottom,</span><br><span class="line">                target.right + child.measuredWidth,</span><br><span class="line">                target.bottom + child.measuredHeight</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>xml</code>中，使用这个<code>Behavior</code>即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:ignore</span>=<span class="string">&quot;HardcodedText&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#00FF00d&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;com.example.viewdemo.LayoutBehavior&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后运行即可看到<code>ImageView</code>被放置在了<code>Button</code>的右下角：</p><p><img alt="behavior-layout.png" class="lozad post-image" src="/img/behavior-layout.png" data-src="/img/behavior-layout.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E"></p><h4 id="布局依赖"><a href="#布局依赖" class="headerlink" title="布局依赖"></a>布局依赖</h4><p><code>Behavior</code>可以实现两个子<code>View</code>之间的布局依赖的关系，当被依赖的<code>View</code>发生位置尺寸的变化或者被移除时，另一个<code>View</code>也会触发相应的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">layoutDependsOn</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout parent, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View dependency</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>首先，在<code>Behavior</code>中通过<code>layoutDependsOn</code>方法来确定依赖关系。方法的第三个参数就是需要依赖的View，该方法会调用多次，也就是说<code>Behavior</code>会遍历除了<code>child</code>外的其他<code>view</code>，然后通过这个方法去判断其是否是child的依赖。</p><p>例如<code>parent</code>有三个子<code>View</code>，其中有一个<code>View</code>设置了<code>Behavior</code>，那么<code>layoutDependsOn</code>方法会被调用两次，其中<code>parent</code>和<code>child</code>参数不变，每次变的是<code>dependency</code>参数。当返回true时，会记录该View，作为其依赖项，因此，<strong>依赖关系是一对多的</strong>。</p><blockquote><p>注意，在Behavior中，都是用parent代表父布局，child代表设置了Behavior的子View</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onDependentViewChanged</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout parent, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View dependency</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p><code>onDependentViewChanged</code>则是依赖发生时调用的方法了，可以在这个方法中去声明<code>child</code>对依赖的响应行为。同样的，若是在这个方法中修改了<code>child</code>的尺寸或者位置，则需要返回<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDependentViewRemoved</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout parent, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View dependency</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p><code>onDependentViewRemoved</code>方法是发生在被依赖的<code>View</code>从父布局中移除的时候，也就是<code>child</code>失去了一个依赖的时候调用。</p><p>示例：</p><p>首先定义一个可移动的按钮<code>MovableButton</code>，因为依赖事件发生的前提是被依赖的<code>View</code>位置或者尺寸发生变化，因此这里需要有一个可以移动位置的<code>View</code>。下面定义一个<code>MovableButton</code>，并没有什么实质内容。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单view，可以跟随手指而动</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovableButton</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attributeSet: AttributeSet? = <span class="literal">null</span></span><br><span class="line">) : AppCompatButton(context, attributeSet) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mInitX = <span class="number">0F</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mInitY = <span class="number">0F</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mEventX = <span class="number">0F</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mEventY = <span class="number">0F</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (event?.actionMasked) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                mInitX = x</span><br><span class="line">                mInitY = y</span><br><span class="line">                mEventX = event.rawX</span><br><span class="line">                mEventY = event.rawY</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                x = mInitX + event.rawX - mEventX</span><br><span class="line">                y = mInitY + event.rawY - mEventY</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始写<code>Behavior</code>，在<code>Behavior</code>中确定依赖关系并且定义相应的操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BelowBehavior</span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attributeSet: AttributeSet</span><br><span class="line">) : CoordinatorLayout.Behavior&lt;View&gt;(context, attributeSet) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">layoutDependsOn</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: <span class="type">CoordinatorLayout</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        child: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dependency: <span class="type">View</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    	<span class="comment">// 设置只有MovableButton才能作为被依赖View</span></span><br><span class="line">        <span class="keyword">return</span> dependency <span class="keyword">is</span> MovableButton</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDependentViewChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: <span class="type">CoordinatorLayout</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        child: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dependency: <span class="type">View</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    	<span class="comment">// 让child一直处在被依赖的View下面</span></span><br><span class="line">        child.y = dependency.height + dependency.translationY</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDependentViewRemoved</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: <span class="type">CoordinatorLayout</span>, child: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dependency: <span class="type">View</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 当被依赖的view被移除的时候，将child的位置重置在界面顶部</span></span><br><span class="line">        child.y = <span class="number">0F</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一点的是，在<code>layoutDependsOn</code>中确定依赖的条件是很简单的，只要<code>View</code>是<code>MovableButton</code>即可。实际中的条件应该更复杂一些的，因为简单的条件很容易形成多个依赖的<code>View</code>。</p><p>然后是在<code>xml</code>中使用<code>Behavior</code>，注意后面都是在<code>xml</code>中使用<code>Behavior</code>，因为比较简单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.viewdemo.MovableButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:ignore</span>=<span class="string">&quot;HardcodedText&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#00FF00&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;com.example.viewdemo.BelowBehavior&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后是效果图如下：</p><p><img alt="behavior-dependency.gif" class="lozad post-image" src="/img/behavior-dependen.webp" data-src="/img/behavior-dependen.webp" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E"></p><h4 id="事件拦截处理"><a href="#事件拦截处理" class="headerlink" title="事件拦截处理"></a>事件拦截处理</h4><p>在<code>View</code>的事件分发中，事件都是先分发给最里层的子<code>View</code>的，当子<code>View</code>决定不处理<code>touch</code>事件的时候，外层的父布局才会得到处理事件的机会。但这也不是一定的，因为父布局中有一个方法可以用来拦截事件，这样事件就会直接交给父布局进行处理，而不会传递给子<code>View</code>了。</p><p><code>CoordinatorLayout</code>作为一个父布局(<code>ViewGroup</code>)一定也是有这个拦截的功能的，但是同样的，它本身也没去实现拦截的机制，而是将这个功能抽取到<code>Behavior</code>中，由<code>Behavior</code>去决定<code>CoordinatorLayout</code>是否拦截此次的事件。当决定拦截了事件后，同样的<code>CoordinatorLayout</code>也不去处理这些事件，而是将这些事件传递给决定拦截事件的这些<code>Behavior</code>中，由<code>Behavior</code>去处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout parent, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> MotionEvent ev</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout parent, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> MotionEvent ev</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>和<code>ViewGroup</code>一样的方法，通过<code>onInterceptTouchEvent</code>进行拦截，然后在<code>onTouchEvent</code>中去处理。<code>Behavior</code>是服务child的，因此这里的事件拦截也仅是为了child而拦截的。让child在事件分发之前就能提前拦截到触摸事件。</p><h4 id="嵌套滑动"><a href="#嵌套滑动" class="headerlink" title="嵌套滑动"></a>嵌套滑动</h4><p><code>Behavior</code>还有一个比较常用的就是嵌套滑动。嵌套滑动的设计能够将一次事件流交给多个<code>View</code>去处理，从而可以让滑动更加流畅更加符合我们的期望。它使用两套接口来实现这种功能，分别是<code>NestedScrollingChild3</code>和<code>NestedScrollingParent3</code>，对应着子<code>View</code>和父<code>View</code>，当然也可以同时实现这两个接口，这样就可以为所欲为了。</p><p>虽然<code>CoordinatorLayout</code>也实现了<code>NestedScrollingParent3</code>接口，但是它并不是像传统的那种嵌套滑动一样来处理滑动事件，而是将滑动事件委托给了<code>Behavior</code>，也就是在嵌套滑动中，实际上是<code>Behavior</code>来作为<code>parent</code>处理滑动事件的。也就是说，<code>CoordinatorLayout</code>中的嵌套滑动并不需要嵌套，同时，由于在嵌套滑动中作为<code>parent</code>的是<code>Behavior</code>，所以实际上想要作为<code>parent</code>的子<code>View</code>只需要设置<code>Behavior</code>即可，而不用去实现<code>NestedScrollingParent3</code>接口。</p><p>总之，**<code>CoordinatorLayout</code>使用嵌套滑动逻辑实现了一套不是嵌套滑动的嵌套滑动**。</p><blockquote><p>注意，嵌套滑动必须由<code>NestedScrollingChild3</code>发起，<code>RecyclerView</code>就实现了这个接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onStartNestedScroll</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View directTargetChild, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View target,</span></span><br><span class="line"><span class="params">    <span class="meta">@ScrollAxis</span> <span class="type">int</span> axes, </span></span><br><span class="line"><span class="params">    <span class="meta">@NestedScrollType</span> <span class="type">int</span> type</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>这是嵌套滑动开始的方法，当发生嵌套滑动的时候，会先调用这个方法，判断<code>Behavior</code>是否需要参与此次的滑动，返回<code>true</code>表示参与这次滑动，才会有后续的方法调用，否则后续的事件都不会再回调到这个<code>Behavior</code>中。</p><p>其中前两个参数不用说了，第三个参数<code>directTargetChild</code>是发生滑动的<code>View</code>在<code>CoordinatorLayout</code>中的直接子布局，而<code>target</code>表示的是发生滑动的那个<code>View</code>。当<code>target</code>直接出现在<code>CoordinatorLayout</code>中的时候，这时候的<code>directTargetChild</code>和<code>target</code>是同一个对象。如下布局中，<code>directTargetChild</code>就是<code>FrameLayout</code>，而<code>target</code>是<code>RecyclerView</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout...</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后两个参数是一个是滚动的方向，一个是滚动的类型。<code>axes</code>表示滑动的方向，有水平和垂直两种类型，取值为<code>ViewCompat#SCROLL_AXIS_HORIZONTAL</code>和<code>ViewCompat#SCROLL_AXIS_VERTICAL</code>。而<code>type</code>表示滑动的类型，有触摸滚动和非触摸滚动（惯性滚动），取值为<code>ViewCompat#TYPE_TOUCH</code>和<code>ViewCompat#TYPE_NON_TOUCH</code>。当<code>Behavior</code>想要参与此次的嵌套滑动的时候，需要返回<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedScrollAccepted</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View directTargetChild, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View target,</span></span><br><span class="line"><span class="params">    <span class="meta">@ScrollAxis</span> <span class="type">int</span> axes, </span></span><br><span class="line"><span class="params">    <span class="meta">@NestedScrollType</span> <span class="type">int</span> type</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p><code>onNestedScrollAccepted</code>的参数和<code>onStartNestedScroll</code>是一样的，这个方法是当<code>onStartNestedScroll</code>返回<code>true</code>的时候调用的，他与<code>onStartNestedScroll</code>是绑定在一起的，每次<code>onStartNestedScroll</code>返回<code>true</code>都会调用一次这个方法。可以在该方法中去处理嵌套滑动的前置准备，如初始化状态等；当然，也可以选择在<code>onStartNestedScroll</code>就初始化状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedPreScroll</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View target, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> dx, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> dy, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> <span class="type">int</span>[] consumed,</span></span><br><span class="line"><span class="params">    <span class="meta">@NestedScrollType</span> <span class="type">int</span> type</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedScroll</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View target, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> dxConsumed, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> dyConsumed, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> dxUnconsumed,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> dyUnconsumed, </span></span><br><span class="line"><span class="params">    <span class="meta">@NestedScrollType</span> <span class="type">int</span> type, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> <span class="type">int</span>[] consumed</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>上面两个方法才是真正滑动的时候回调的方法。在发生嵌套滑动并且<code>Behavior</code>接受了这次滑动后，会先调用<code>onNestedPreScroll</code>方法。注意这个方法是发生在<code>Behavior</code>中的，也就是说，当有滑动事件的时候，是优先传递给<code>Behavior</code>去处理的。其中参数<code>dx</code>和<code>dy</code>表示的是滑动的距离，而数组<code>consumed</code>的长度为2，表示的是<code>Behavior</code>消耗的滑动距离。<code>consumed[0]</code>为对<code>dx</code>的消耗，<code>consumed[1]</code>为对<code>dy</code>的消耗，当<code>Behavior</code>消耗滑动后，需要手动的将消耗的多少填充到数组中。</p><p>当<code>Behavior</code>处理完后，剩余的事件会传递给<code>target</code>去处理，当然这时候的处理跟我们无关了，是由<code>target</code>本身的逻辑去处理了。而当<code>target</code>滚动结束后，剩下的事件又会传递到<code>parent</code>中进而传递给<code>Behavior</code>的<code>onNestedScroll</code>方法。该方法的中间四个参数没什么可说的，从名字就可以看出是<code>dx</code>和<code>dy</code>的已消耗的和未消耗的值。<code>consumed</code>数组也是一样的，存放消耗的事件。注意的是，此时<code>consumed</code>数据可能是已经有值的，因此我们消耗后，需要进行叠加而不是赋值。例如消耗<code>deltaY</code>，则应该<code>consumed[1] += deltaY</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNestedPreFling</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View target, </span></span><br><span class="line"><span class="params">    <span class="type">float</span> velocityX, </span></span><br><span class="line"><span class="params">    <span class="type">float</span> velocityY</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNestedFling</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> V child, </span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> View target, </span></span><br><span class="line"><span class="params">    <span class="type">float</span> velocityX, </span></span><br><span class="line"><span class="params">    <span class="type">float</span> velocityY,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> consumed</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>当子<code>View</code>发生惯性滑动也就是<code>fling</code>的时候，同样是先传递给<code>Behavior</code>。也就是<code>onNestedPreFling</code>方法，<code>Behavior</code>需要在这个方法中去判断是否需要消耗这次的惯性滑动，若是需要的话则返回<code>true</code>。然后就是再交还给子<code>View</code>去进行判断是否需要显示<code>overScroll</code>，然后再通过<code>onNestedFling</code>传递回<code>Behavior</code>中进行真正的惯性滑动处理。其中参数<code>consumed</code>表示嵌套子<code>View</code>(发起滚动的子<code>View</code>)是否消耗此次惯性滑动，若是<code>Behavior</code>需要消耗此次滚动，则需要返回<code>true</code>。</p><p><em>这是<code>NestedScrollingParent</code>中的机制，而在<code>NestedScrollingParent2/3</code>中，已经取消了这种惯性滑动的处理方式，而是采用<code>Child</code>去消耗滑动，产生的滑动再次分发的形式。<strong>因此，实际上这两个方法都不用重写的，直接保持默认的实现就行了</strong>。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStopNestedScroll</span><span class="params">(</span></span><br><span class="line"><span class="params">     <span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><br><span class="line"><span class="params">     <span class="meta">@NonNull</span> V child, </span></span><br><span class="line"><span class="params">     <span class="meta">@NonNull</span> View target, </span></span><br><span class="line"><span class="params">     <span class="meta">@NestedScrollType</span> <span class="type">int</span> type</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>在滚动结束后，会调用<code>onStopNestedScroll</code>方法，可以在这个方法中去做一些收尾工作。所以嵌套滑动一共涉及到七个方法，滑动刚开始的两个方法，滑动过程中的两个方法，惯性滑动的两个方法，以及收尾的一个方法。并且，滑动事件的顺序都是<code>子View-&gt;Behavior-&gt;子View-&gt;Behavior</code>。因此滑动过程和惯性滑动过程都是两个方法，一个是第一次开始处理，一个是子<code>View</code>处理后剩下的再去处理。</p><p>下面实现一个示例，给<code>RecyclerView</code>添加一个Header：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#00FFFF&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Header&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;.NestedBehavior&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layoutManager</span>=<span class="string">&quot;androidx.recyclerview.widget.LinearLayoutManager&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;.ToBottomBehavior&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:listitem</span>=<span class="string">&quot;@layout/item_text&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>整体布局如上所示，要实现添加Header的效果，需要两步，一是将<code>RecyclerView</code>放置在Header的下面，一是跟随滑动。由于<code>CoordinatorLayout</code>的默认布局效果是堆叠的方式，所以需要我们自己去进行布局，这里定义一个<code>ToBottomBehavior</code>，作用与<code>RecyclerView</code>，用于让其一直处于Header的下方：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ToBottomBehavior</span>(context: Context,attr: AttributeSet) : Behavior&lt;RecyclerView&gt;(context, attr) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayoutChild</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: <span class="type">CoordinatorLayout</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        child: <span class="type">RecyclerView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        layoutDirection: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.childCount &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将RecyclerView放置在Header的下面</span></span><br><span class="line">        <span class="keyword">val</span> first = parent.getChildAt(<span class="number">0</span>)</span><br><span class="line">        child.layout(<span class="number">0</span>, first.measuredHeight, first.measuredWidth, child.measuredHeight)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">layoutDependsOn</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: <span class="type">CoordinatorLayout</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        child: <span class="type">RecyclerView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dependency: <span class="type">View</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency <span class="keyword">is</span> TextView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDependentViewChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: <span class="type">CoordinatorLayout</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        child: <span class="type">RecyclerView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dependency: <span class="type">View</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">// 当Header的 位置发生变化时，继续挪动RecyclerView，让其一直在Header下方</span></span><br><span class="line">        child.layout(</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            (dependency.bottom + dependency.translationY).toInt(),</span><br><span class="line">            child.measuredWidth,</span><br><span class="line">            child.measuredHeight</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再定义一个<code>NestedBehavior</code>，让Header跟随RecyclerView进行滑动：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestedBehavior</span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = <span class="literal">null</span></span><br><span class="line">) : CoordinatorLayout.Behavior&lt;View&gt;(context, attr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartNestedScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        coordinatorLayout: <span class="type">CoordinatorLayout</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        child: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        directTargetChild: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        target: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        axes: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">// 只拦截纵向的滚动</span></span><br><span class="line">        <span class="keyword">return</span> axes == ViewCompat.SCROLL_AXIS_VERTICAL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedPreScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        coordinatorLayout: <span class="type">CoordinatorLayout</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        child: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        target: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dx: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dy: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        consumed: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 注意，手指向上滑动的时候，dy大于0。向下的时候dy小于0。</span></span><br><span class="line">        <span class="keyword">val</span> translationY = child.translationY</span><br><span class="line">        <span class="keyword">if</span> (-translationY &gt;= child.measuredHeight || dy &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// child已经滚动到屏幕外了，或者向下滚动，就不去消耗滚动了</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还差这么desireHeight距离将会移出屏幕外</span></span><br><span class="line">        <span class="keyword">val</span> desireHeight = translationY + child.measuredHeight</span><br><span class="line">        <span class="keyword">if</span> (dy &lt;= desireHeight) &#123;</span><br><span class="line">            <span class="comment">// 将dy全部消耗掉</span></span><br><span class="line">            child.translationY = translationY - dy</span><br><span class="line">            consumed[<span class="number">1</span>] = dy</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 消耗一部分的的dy</span></span><br><span class="line">            child.translationY = translationY - desireHeight</span><br><span class="line">            consumed[<span class="number">1</span>] = desireHeight.toInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        coordinatorLayout: <span class="type">CoordinatorLayout</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        child: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        target: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dxConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dyConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dxUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dyUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        type: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        consumed: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> translationY = child.translationY</span><br><span class="line">        <span class="keyword">if</span> (translationY &gt;= <span class="number">0</span> || dyUnconsumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 手指向上滚动或者child已经滚出了屏幕，不去处理</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dyUnconsumed &gt; translationY) &#123;</span><br><span class="line">            <span class="comment">// 全部消耗</span></span><br><span class="line">            consumed[<span class="number">1</span>] += dyUnconsumed</span><br><span class="line">            child.translationY = translationY - dyUnconsumed</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 消耗一部分</span></span><br><span class="line">            consumed[<span class="number">1</span>] += child.translationY.toInt()</span><br><span class="line">            child.translationY = <span class="number">0F</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后随便设置一下RecyclerView的Adapter等，效果如下：</p><p><img alt="behavior-nested.webp" class="lozad post-image" src="/img/behavior-nested.webp" data-src="/img/behavior-nested.webp" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先，<code>Behavior</code>是一个插件，它是<code>CoordinatorLayout</code>抽取出来的一个标准。<code>CoordinatorLayout</code>将本身的各种能力抽取到了<code>Behavior</code>中，在需要的时候去加载它从而实现某些交互。</p><p>其次，<code>Behavior</code>一共有四种能力：<strong>测量布局，位置依赖，事件拦截，嵌套滑动</strong>。其中依赖和嵌套滑动用的是最多的，然后是布局和测量，最后才是touch。</p><p>当学会了<code>Behavior</code>的各个方法的使用后，就可以设计出各种花里胡哨的操作了，也就学会了Behavior了。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Tue Nov 02 2021 21:54:58 GMT+0800"),n=new Date("Sat Jun 29 2024 12:59:12 GMT+0800"),t=Math.floor((e-t)/864e5),e=Math.floor((e-n)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Android/" class="post-footer-category">#&nbsp;Android</a> <a href="/categories/Android/Behavior/" class="post-footer-category">#&nbsp;Behavior</a> <a href="/tags/View/" class="post-footer-tag">#&nbsp;View</a></div><div class="nav"><div class="nav-item-prev"><a href="/2021/11/22/Android%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E4%B9%8B%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8/" class="nav-link"><i class="iconfont icon-left nav-prev-icon"></i><div><div class="nav-label">上一篇</div><div class="nav-title">Android滑动事件之嵌套滑动</div></div></a></div><div class="nav-item-next"><a href="/2021/09/06/%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8Bsdiff%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">在Android中使用Bsdiff实现增量更新</div></div><i class="iconfont icon-right nav-next-icon"></i></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Behavior%E7%9A%84%E8%83%BD%E5%8A%9B" class="toc-link"><span class="toc-text">Behavior的能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%AE%BE%E7%BD%AEBehavior" class="toc-link"><span class="toc-text">如何使用设置Behavior</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#xml%E4%B8%AD%E8%AE%BE%E7%BD%AE" class="toc-link"><span class="toc-text">xml中设置</span></a></li><li class="toc-item toc-level-4"><a href="#%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B" class="toc-link"><span class="toc-text">直接创建实例</span></a></li><li class="toc-item toc-level-4"><a href="#%E9%80%9A%E8%BF%87%E9%BB%98%E8%AE%A4%E7%9A%84Behavior%E8%AE%BE%E7%BD%AE" class="toc-link"><span class="toc-text">通过默认的Behavior设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#Behavior%E7%9A%84%E5%8A%9F%E8%83%BD" class="toc-link"><span class="toc-text">Behavior的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80" class="toc-link"><span class="toc-text">测量和布局</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%B8%83%E5%B1%80%E4%BE%9D%E8%B5%96" class="toc-link"><span class="toc-text">布局依赖</span></a></li><li class="toc-item toc-level-4"><a href="#%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA%E5%A4%84%E7%90%86" class="toc-link"><span class="toc-text">事件拦截处理</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8" class="toc-link"><span class="toc-text">嵌套滑动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2099-12-31</div><a href="/2099/12/31/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"><div class="recent-posts-item-content">【置顶】博客文章思维导图</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-11-22</div><a href="/2021/11/22/Android%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E4%B9%8B%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8/"><div class="recent-posts-item-content">Android滑动事件之嵌套滑动</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-11-02</div><a href="/2021/11/02/CoordinatorLayout%E7%9A%84%E7%A7%98%E5%AF%86%E4%B9%8BBehavior/"><div class="recent-posts-item-content">CoordinatorLayout的秘密之Behavior</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-09-06</div><a href="/2021/09/06/%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8Bsdiff%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"><div class="recent-posts-item-content">在Android中使用Bsdiff实现增量更新</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-08-05</div><a href="/2021/08/05/%E5%B0%86Room%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%A1%9E%E5%88%B0%E8%84%91%E5%AD%90%E9%87%8C/"><div class="recent-posts-item-content">将Room的使用方式塞到脑子里</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2099-12-31</div><a href="/2099/12/31/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"><div class="recent-posts-item-content">【置顶】博客文章思维导图</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-11-22</div><a href="/2021/11/22/Android%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E4%B9%8B%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8/"><div class="recent-posts-item-content">Android滑动事件之嵌套滑动</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-11-02</div><a href="/2021/11/02/CoordinatorLayout%E7%9A%84%E7%A7%98%E5%AF%86%E4%B9%8BBehavior/"><div class="recent-posts-item-content">CoordinatorLayout的秘密之Behavior</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-09-06</div><a href="/2021/09/06/%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8Bsdiff%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"><div class="recent-posts-item-content">在Android中使用Bsdiff实现增量更新</div></a></div></div></div></article></div></aside></div></div></div></div><script src="/js/main.js"></script><script>var addLazyload=function(){lozad(".lozad",{load:function(a){a.srcset=a.getAttribute("data-src")},loaded:function(a){a.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>tocSetup())</script></body></html>